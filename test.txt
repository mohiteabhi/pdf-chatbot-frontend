require("dotenv").config();
const express = require("express");
const cors = require("cors");
const multer = require("multer");
const pdfParse = require("pdf-parse");
const fs = require("fs");
const path = require("path");
const sharp = require("sharp");
const Tesseract = require("tesseract.js");
const { fromPath } = require("pdf2pic");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { execFile } = require("child_process");
const util = require("util");
const execFileAsync = util.promisify(execFile);
const os = require("os");

const app = express();
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);

app.use(cors({ origin: "http://localhost:3000" }));
app.use(express.json());

const UPLOAD_DIR = path.join(__dirname, "uploads");
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR);

const storage = multer.diskStorage({
  destination: (_, __, cb) => cb(null, UPLOAD_DIR),
  filename: (_, file, cb) => cb(null, `${Date.now()}-${file.originalname}`)
});
const upload = multer({ storage });

let documentText = "";

/**
 * Extract text from PDFs (with scanned fallback) or images.
 */
async function extractText(filePath) {
  const ext = path.extname(filePath).toLowerCase();

  if (ext === ".pdf") {
    // 1) Try pdf-parse first
    const raw = fs.readFileSync(filePath);
    const { text: parsedText, info } = await pdfParse(raw);
    if ((parsedText || "").trim().length > 50) {
      return parsedText;
    }

    // 2) Fallback: scanned PDF → rasterize & OCR each page
    console.log("Scanned PDF detected – falling back to pdftoppm+OCR…");

    const pages = info.Pages || 1;
    const ocrPages = [];

    for (let page = 1; page <= pages; page++) {
      // create a unique prefix in temp
      const prefix = path.join(os.tmpdir(), `scan-${Date.now()}-${page}`);
      // pdftoppm flags:
      // -png         → output PNG
      // -singlefile  → no "-1" suffix
      // -r 300       → 300 DPI
      // -f, -l       → first & last page = this page
      await execFileAsync("pdftoppm", [
        "-png",
        "-singlefile",
        "-r",
        "300",
        "-f",
        `${page}`,
        "-l",
        `${page}`,
        filePath,
        prefix
      ]);

      const pngPath = `${prefix}.png`;
      // preprocess with sharp
      const imgBuf = await sharp(pngPath)
        .grayscale()
        .sharpen()
        .normalize()
        .toBuffer();

      // OCR with Tesseract
      const {
        data: { text }
      } = await Tesseract.recognize(imgBuf, "eng", {
        logger: (m) => console.log(`Tesseract page ${page}:`, m)
      });

      ocrPages.push(text);
      // remove temp PNG
      fs.unlinkSync(pngPath);
    }

    return ocrPages.join("\n\n");
  }

  // === image support unchanged ===
  if ([".png", ".jpg", ".jpeg", ".bmp"].includes(ext)) {
    const imgBuf = await sharp(filePath)
      .grayscale()
      .sharpen()
      .normalize()
      .toBuffer();

    const {
      data: { text }
    } = await Tesseract.recognize(imgBuf, "eng", {
      logger: (m) => console.log("Tesseract:", m)
    });
    return text;
  }

  throw new Error("Unsupported file type");
}

async function askGemini(prompt) {
  const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
  const result = await model.generateContent(prompt);
  return await result.response.text();
}

function detectRequestedFormat(question) {
  const q = question.toLowerCase();
  if (q.includes("table"))    return "table";
  if (q.includes("json"))     return "json";
  if (q.includes("bullet"))   return "bullets";
  return "default";
}

app.post("/upload", upload.single("file"), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: "No file uploaded." });
  }
  try {
    const savedPath = req.file.path;
    documentText = await extractText(savedPath);
    console.log(`Extracted ${documentText.length} chars from ${savedPath}`);
    res.json({ message: "File uploaded and text extracted." });
  } catch (err) {
    console.error("Extraction error:", err);
    res.status(500).json({ error: "Failed to extract text." });
  }
});

app.post("/chat", async (req, res) => {
  const { question } = req.body;
  if (!documentText) {
    return res.status(400).json({ error: "Please upload a file first." });
  }
  if (!question?.trim()) {
    return res.status(400).json({ error: "Question cannot be empty." });
  }

  const format = detectRequestedFormat(question);
  let instruction;
  switch (format) {
    case "table":
      instruction = "Respond strictly as a GitHub-Flavored Markdown table with header row and pipes.";
      break;
    case "json":
      instruction = "Respond strictly as valid JSON." ;
      break;
    case "bullets":
      instruction = "Respond as bullet points.";
      break;
    default:
      instruction = "Respond in well-formatted Markdown.";
  }

  const prompt = `
You are an AI assistant. Use the extracted document text below.

Document text:
${documentText}

User’s question: ${question}

${instruction}`;

  try {
    const answer = await askGemini(prompt);
    res.json({ answer, format });
  } catch (err) {
    console.error("AI error:", err);
    res.status(500).json({ error: "AI generation failed." });
  }
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`Backend listening on http://localhost:${PORT}`));


Provide a SPECIFIC answer to the question as a detailed RBI compliance checklist in JSON format. Focus ONLY on the requirements mentioned in the question. Include these fields ONLY if relevant: - `title`: Brief descriptive name - `description`: Detailed requirement SPECIFIC to the question - `activities`: Array of specific activities needed - `periodicity`: How often it must be performed - `regulation_reference`: RBI circular/master direction reference- `action`: 'Actionable' or 'Informational' - `complianceType`: Array of compliance types - `status`: Compliance status 